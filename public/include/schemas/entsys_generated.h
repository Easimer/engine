// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENTSYS_SCHEMAS_ENTITYSYSTEM_H_
#define FLATBUFFERS_GENERATED_ENTSYS_SCHEMAS_ENTITYSYSTEM_H_

#include "flatbuffers/flatbuffers.h"

#include "base_generated.h"

namespace Schemas {
namespace EntitySystem {

struct Value;

struct KeyValue;

struct IOEvent;

struct Entity;

enum ValueType {
  ValueType_Vec3 = 0,
  ValueType_Vec4 = 1,
  ValueType_RGB = 2,
  ValueType_RGBA = 3,
  ValueType_Str = 4,
  ValueType_Float = 5,
  ValueType_Int = 6,
  ValueType_MIN = ValueType_Vec3,
  ValueType_MAX = ValueType_Int
};

inline ValueType (&EnumValuesValueType())[7] {
  static ValueType values[] = {
    ValueType_Vec3,
    ValueType_Vec4,
    ValueType_RGB,
    ValueType_RGBA,
    ValueType_Str,
    ValueType_Float,
    ValueType_Int
  };
  return values;
}

inline const char **EnumNamesValueType() {
  static const char *names[] = {
    "Vec3",
    "Vec4",
    "RGB",
    "RGBA",
    "Str",
    "Float",
    "Int",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueType(ValueType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesValueType()[index];
}

struct Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_VEC3 = 6,
    VT_VEC4 = 8,
    VT_RGB = 10,
    VT_RGBA = 12,
    VT_STRING = 14,
    VT_FLOAT_ = 16,
    VT_INT_ = 18
  };
  ValueType type() const {
    return static_cast<ValueType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const Schemas::Vector3 *vec3() const {
    return GetStruct<const Schemas::Vector3 *>(VT_VEC3);
  }
  const Schemas::Vector4 *vec4() const {
    return GetStruct<const Schemas::Vector4 *>(VT_VEC4);
  }
  const Schemas::ColorRGB *rgb() const {
    return GetStruct<const Schemas::ColorRGB *>(VT_RGB);
  }
  const Schemas::ColorRGBA *rgba() const {
    return GetStruct<const Schemas::ColorRGBA *>(VT_RGBA);
  }
  const flatbuffers::String *string() const {
    return GetPointer<const flatbuffers::String *>(VT_STRING);
  }
  float float_() const {
    return GetField<float>(VT_FLOAT_, 0.0f);
  }
  int32_t int_() const {
    return GetField<int32_t>(VT_INT_, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<Schemas::Vector3>(verifier, VT_VEC3) &&
           VerifyField<Schemas::Vector4>(verifier, VT_VEC4) &&
           VerifyField<Schemas::ColorRGB>(verifier, VT_RGB) &&
           VerifyField<Schemas::ColorRGBA>(verifier, VT_RGBA) &&
           VerifyOffset(verifier, VT_STRING) &&
           verifier.Verify(string()) &&
           VerifyField<float>(verifier, VT_FLOAT_) &&
           VerifyField<int32_t>(verifier, VT_INT_) &&
           verifier.EndTable();
  }
};

struct ValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ValueType type) {
    fbb_.AddElement<uint8_t>(Value::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_vec3(const Schemas::Vector3 *vec3) {
    fbb_.AddStruct(Value::VT_VEC3, vec3);
  }
  void add_vec4(const Schemas::Vector4 *vec4) {
    fbb_.AddStruct(Value::VT_VEC4, vec4);
  }
  void add_rgb(const Schemas::ColorRGB *rgb) {
    fbb_.AddStruct(Value::VT_RGB, rgb);
  }
  void add_rgba(const Schemas::ColorRGBA *rgba) {
    fbb_.AddStruct(Value::VT_RGBA, rgba);
  }
  void add_string(flatbuffers::Offset<flatbuffers::String> string) {
    fbb_.AddOffset(Value::VT_STRING, string);
  }
  void add_float_(float float_) {
    fbb_.AddElement<float>(Value::VT_FLOAT_, float_, 0.0f);
  }
  void add_int_(int32_t int_) {
    fbb_.AddElement<int32_t>(Value::VT_INT_, int_, 0);
  }
  explicit ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ValueBuilder &operator=(const ValueBuilder &);
  flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Value> CreateValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    ValueType type = ValueType_Vec3,
    const Schemas::Vector3 *vec3 = 0,
    const Schemas::Vector4 *vec4 = 0,
    const Schemas::ColorRGB *rgb = 0,
    const Schemas::ColorRGBA *rgba = 0,
    flatbuffers::Offset<flatbuffers::String> string = 0,
    float float_ = 0.0f,
    int32_t int_ = 0) {
  ValueBuilder builder_(_fbb);
  builder_.add_int_(int_);
  builder_.add_float_(float_);
  builder_.add_string(string);
  builder_.add_rgba(rgba);
  builder_.add_rgb(rgb);
  builder_.add_vec4(vec4);
  builder_.add_vec3(vec3);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Value> CreateValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ValueType type = ValueType_Vec3,
    const Schemas::Vector3 *vec3 = 0,
    const Schemas::Vector4 *vec4 = 0,
    const Schemas::ColorRGB *rgb = 0,
    const Schemas::ColorRGBA *rgba = 0,
    const char *string = nullptr,
    float float_ = 0.0f,
    int32_t int_ = 0) {
  return Schemas::EntitySystem::CreateValue(
      _fbb,
      type,
      vec3,
      vec4,
      rgb,
      rgba,
      string ? _fbb.CreateString(string) : 0,
      float_,
      int_);
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const Value *value() const {
    return GetPointer<const Value *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<Value> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueBuilder &operator=(const KeyValueBuilder &);
  flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValue> CreateKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<Value> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    flatbuffers::Offset<Value> value = 0) {
  return Schemas::EntitySystem::CreateKeyValue(
      _fbb,
      key ? _fbb.CreateString(key) : 0,
      value);
}

struct IOEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OUTPUT = 4,
    VT_TARGETNAME = 6,
    VT_INPUT = 8,
    VT_ARGUMENT = 10,
    VT_DELAY = 12,
    VT_ONCE = 14
  };
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  const flatbuffers::String *targetname() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGETNAME);
  }
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *argument() const {
    return GetPointer<const flatbuffers::String *>(VT_ARGUMENT);
  }
  float delay() const {
    return GetField<float>(VT_DELAY, 0.0f);
  }
  bool once() const {
    return GetField<uint8_t>(VT_ONCE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.Verify(output()) &&
           VerifyOffset(verifier, VT_TARGETNAME) &&
           verifier.Verify(targetname()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.Verify(input()) &&
           VerifyOffset(verifier, VT_ARGUMENT) &&
           verifier.Verify(argument()) &&
           VerifyField<float>(verifier, VT_DELAY) &&
           VerifyField<uint8_t>(verifier, VT_ONCE) &&
           verifier.EndTable();
  }
};

struct IOEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(IOEvent::VT_OUTPUT, output);
  }
  void add_targetname(flatbuffers::Offset<flatbuffers::String> targetname) {
    fbb_.AddOffset(IOEvent::VT_TARGETNAME, targetname);
  }
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(IOEvent::VT_INPUT, input);
  }
  void add_argument(flatbuffers::Offset<flatbuffers::String> argument) {
    fbb_.AddOffset(IOEvent::VT_ARGUMENT, argument);
  }
  void add_delay(float delay) {
    fbb_.AddElement<float>(IOEvent::VT_DELAY, delay, 0.0f);
  }
  void add_once(bool once) {
    fbb_.AddElement<uint8_t>(IOEvent::VT_ONCE, static_cast<uint8_t>(once), 0);
  }
  explicit IOEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IOEventBuilder &operator=(const IOEventBuilder &);
  flatbuffers::Offset<IOEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IOEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<IOEvent> CreateIOEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> output = 0,
    flatbuffers::Offset<flatbuffers::String> targetname = 0,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> argument = 0,
    float delay = 0.0f,
    bool once = false) {
  IOEventBuilder builder_(_fbb);
  builder_.add_delay(delay);
  builder_.add_argument(argument);
  builder_.add_input(input);
  builder_.add_targetname(targetname);
  builder_.add_output(output);
  builder_.add_once(once);
  return builder_.Finish();
}

inline flatbuffers::Offset<IOEvent> CreateIOEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *output = nullptr,
    const char *targetname = nullptr,
    const char *input = nullptr,
    const char *argument = nullptr,
    float delay = 0.0f,
    bool once = false) {
  return Schemas::EntitySystem::CreateIOEvent(
      _fbb,
      output ? _fbb.CreateString(output) : 0,
      targetname ? _fbb.CreateString(targetname) : 0,
      input ? _fbb.CreateString(input) : 0,
      argument ? _fbb.CreateString(argument) : 0,
      delay,
      once);
}

struct Entity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSNAME = 4,
    VT_KEYVALUES = 6,
    VT_OUTPUTS = 8
  };
  const flatbuffers::String *classname() const {
    return GetPointer<const flatbuffers::String *>(VT_CLASSNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *keyvalues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *>(VT_KEYVALUES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<IOEvent>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<IOEvent>> *>(VT_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CLASSNAME) &&
           verifier.Verify(classname()) &&
           VerifyOffset(verifier, VT_KEYVALUES) &&
           verifier.Verify(keyvalues()) &&
           verifier.VerifyVectorOfTables(keyvalues()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.Verify(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           verifier.EndTable();
  }
};

struct EntityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classname(flatbuffers::Offset<flatbuffers::String> classname) {
    fbb_.AddOffset(Entity::VT_CLASSNAME, classname);
  }
  void add_keyvalues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> keyvalues) {
    fbb_.AddOffset(Entity::VT_KEYVALUES, keyvalues);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IOEvent>>> outputs) {
    fbb_.AddOffset(Entity::VT_OUTPUTS, outputs);
  }
  explicit EntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityBuilder &operator=(const EntityBuilder &);
  flatbuffers::Offset<Entity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entity>(end);
    fbb_.Required(o, Entity::VT_CLASSNAME);
    return o;
  }
};

inline flatbuffers::Offset<Entity> CreateEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> classname = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> keyvalues = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IOEvent>>> outputs = 0) {
  EntityBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_keyvalues(keyvalues);
  builder_.add_classname(classname);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entity> CreateEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *classname = nullptr,
    const std::vector<flatbuffers::Offset<KeyValue>> *keyvalues = nullptr,
    const std::vector<flatbuffers::Offset<IOEvent>> *outputs = nullptr) {
  return Schemas::EntitySystem::CreateEntity(
      _fbb,
      classname ? _fbb.CreateString(classname) : 0,
      keyvalues ? _fbb.CreateVector<flatbuffers::Offset<KeyValue>>(*keyvalues) : 0,
      outputs ? _fbb.CreateVector<flatbuffers::Offset<IOEvent>>(*outputs) : 0);
}

}  // namespace EntitySystem
}  // namespace Schemas

#endif  // FLATBUFFERS_GENERATED_ENTSYS_SCHEMAS_ENTITYSYSTEM_H_
