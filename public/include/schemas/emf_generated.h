// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMF_SCHEMAS_MAP_H_
#define FLATBUFFERS_GENERATED_EMF_SCHEMAS_MAP_H_

#include "flatbuffers/flatbuffers.h"

#include "base_generated.h"

namespace Schemas {
namespace Map {

struct KeyValueInt;

struct KeyValueFloat;

struct KeyValueString;

struct KeyValueVector;

struct KeyValue;

struct Entity;

struct Header;

enum KeyValueValue {
  KeyValueValue_NONE = 0,
  KeyValueValue_KeyValueInt = 1,
  KeyValueValue_KeyValueFloat = 2,
  KeyValueValue_KeyValueString = 3,
  KeyValueValue_KeyValueVector = 4,
  KeyValueValue_MIN = KeyValueValue_NONE,
  KeyValueValue_MAX = KeyValueValue_KeyValueVector
};

inline KeyValueValue (&EnumValuesKeyValueValue())[5] {
  static KeyValueValue values[] = {
    KeyValueValue_NONE,
    KeyValueValue_KeyValueInt,
    KeyValueValue_KeyValueFloat,
    KeyValueValue_KeyValueString,
    KeyValueValue_KeyValueVector
  };
  return values;
}

inline const char **EnumNamesKeyValueValue() {
  static const char *names[] = {
    "NONE",
    "KeyValueInt",
    "KeyValueFloat",
    "KeyValueString",
    "KeyValueVector",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyValueValue(KeyValueValue e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesKeyValueValue()[index];
}

template<typename T> struct KeyValueValueTraits {
  static const KeyValueValue enum_value = KeyValueValue_NONE;
};

template<> struct KeyValueValueTraits<KeyValueInt> {
  static const KeyValueValue enum_value = KeyValueValue_KeyValueInt;
};

template<> struct KeyValueValueTraits<KeyValueFloat> {
  static const KeyValueValue enum_value = KeyValueValue_KeyValueFloat;
};

template<> struct KeyValueValueTraits<KeyValueString> {
  static const KeyValueValue enum_value = KeyValueValue_KeyValueString;
};

template<> struct KeyValueValueTraits<KeyValueVector> {
  static const KeyValueValue enum_value = KeyValueValue_KeyValueVector;
};

bool VerifyKeyValueValue(flatbuffers::Verifier &verifier, const void *obj, KeyValueValue type);
bool VerifyKeyValueValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct KeyValueInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct KeyValueIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(KeyValueInt::VT_VALUE, value, 0);
  }
  explicit KeyValueIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueIntBuilder &operator=(const KeyValueIntBuilder &);
  flatbuffers::Offset<KeyValueInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValueInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValueInt> CreateKeyValueInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  KeyValueIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct KeyValueFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct KeyValueFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(KeyValueFloat::VT_VALUE, value, 0.0f);
  }
  explicit KeyValueFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueFloatBuilder &operator=(const KeyValueFloatBuilder &);
  flatbuffers::Offset<KeyValueFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValueFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValueFloat> CreateKeyValueFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  KeyValueFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct KeyValueString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(KeyValueString::VT_VALUE, value);
  }
  explicit KeyValueStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueStringBuilder &operator=(const KeyValueStringBuilder &);
  flatbuffers::Offset<KeyValueString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValueString>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValueString> CreateKeyValueString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  KeyValueStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValueString> CreateKeyValueStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return Schemas::Map::CreateKeyValueString(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct KeyValueVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const Schemas::Vector3 *value() const {
    return GetStruct<const Schemas::Vector3 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Schemas::Vector3>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct KeyValueVectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Schemas::Vector3 *value) {
    fbb_.AddStruct(KeyValueVector::VT_VALUE, value);
  }
  explicit KeyValueVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueVectorBuilder &operator=(const KeyValueVectorBuilder &);
  flatbuffers::Offset<KeyValueVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValueVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValueVector> CreateKeyValueVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Schemas::Vector3 *value = 0) {
  KeyValueVectorBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  KeyValueValue value_type() const {
    return static_cast<KeyValueValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const KeyValueInt *value_as_KeyValueInt() const {
    return value_type() == KeyValueValue_KeyValueInt ? static_cast<const KeyValueInt *>(value()) : nullptr;
  }
  const KeyValueFloat *value_as_KeyValueFloat() const {
    return value_type() == KeyValueValue_KeyValueFloat ? static_cast<const KeyValueFloat *>(value()) : nullptr;
  }
  const KeyValueString *value_as_KeyValueString() const {
    return value_type() == KeyValueValue_KeyValueString ? static_cast<const KeyValueString *>(value()) : nullptr;
  }
  const KeyValueVector *value_as_KeyValueVector() const {
    return value_type() == KeyValueValue_KeyValueVector ? static_cast<const KeyValueVector *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyKeyValueValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const KeyValueInt *KeyValue::value_as<KeyValueInt>() const {
  return value_as_KeyValueInt();
}

template<> inline const KeyValueFloat *KeyValue::value_as<KeyValueFloat>() const {
  return value_as_KeyValueFloat();
}

template<> inline const KeyValueString *KeyValue::value_as<KeyValueString>() const {
  return value_as_KeyValueString();
}

template<> inline const KeyValueVector *KeyValue::value_as<KeyValueVector>() const {
  return value_as_KeyValueVector();
}

struct KeyValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value_type(KeyValueValue value_type) {
    fbb_.AddElement<uint8_t>(KeyValue::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueBuilder &operator=(const KeyValueBuilder &);
  flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValue> CreateKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    KeyValueValue value_type = KeyValueValue_NONE,
    flatbuffers::Offset<void> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    KeyValueValue value_type = KeyValueValue_NONE,
    flatbuffers::Offset<void> value = 0) {
  return Schemas::Map::CreateKeyValue(
      _fbb,
      key ? _fbb.CreateString(key) : 0,
      value_type,
      value);
}

struct Entity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSNAME = 4,
    VT_TARGETNAME = 6,
    VT_KEYVALUES = 8
  };
  const flatbuffers::String *classname() const {
    return GetPointer<const flatbuffers::String *>(VT_CLASSNAME);
  }
  const flatbuffers::String *targetname() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGETNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *keyvalues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *>(VT_KEYVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLASSNAME) &&
           verifier.Verify(classname()) &&
           VerifyOffset(verifier, VT_TARGETNAME) &&
           verifier.Verify(targetname()) &&
           VerifyOffset(verifier, VT_KEYVALUES) &&
           verifier.Verify(keyvalues()) &&
           verifier.VerifyVectorOfTables(keyvalues()) &&
           verifier.EndTable();
  }
};

struct EntityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classname(flatbuffers::Offset<flatbuffers::String> classname) {
    fbb_.AddOffset(Entity::VT_CLASSNAME, classname);
  }
  void add_targetname(flatbuffers::Offset<flatbuffers::String> targetname) {
    fbb_.AddOffset(Entity::VT_TARGETNAME, targetname);
  }
  void add_keyvalues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> keyvalues) {
    fbb_.AddOffset(Entity::VT_KEYVALUES, keyvalues);
  }
  explicit EntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityBuilder &operator=(const EntityBuilder &);
  flatbuffers::Offset<Entity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entity>(end);
    return o;
  }
};

inline flatbuffers::Offset<Entity> CreateEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> classname = 0,
    flatbuffers::Offset<flatbuffers::String> targetname = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> keyvalues = 0) {
  EntityBuilder builder_(_fbb);
  builder_.add_keyvalues(keyvalues);
  builder_.add_targetname(targetname);
  builder_.add_classname(classname);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entity> CreateEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *classname = nullptr,
    const char *targetname = nullptr,
    const std::vector<flatbuffers::Offset<KeyValue>> *keyvalues = nullptr) {
  return Schemas::Map::CreateEntity(
      _fbb,
      classname ? _fbb.CreateString(classname) : 0,
      targetname ? _fbb.CreateString(targetname) : 0,
      keyvalues ? _fbb.CreateVector<flatbuffers::Offset<KeyValue>>(*keyvalues) : 0);
}

struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeaderBuilder &operator=(const HeaderBuilder &);
  flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline flatbuffers::Offset<Header> CreateHeader(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeaderBuilder builder_(_fbb);
  return builder_.Finish();
}

inline bool VerifyKeyValueValue(flatbuffers::Verifier &verifier, const void *obj, KeyValueValue type) {
  switch (type) {
    case KeyValueValue_NONE: {
      return true;
    }
    case KeyValueValue_KeyValueInt: {
      auto ptr = reinterpret_cast<const KeyValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KeyValueValue_KeyValueFloat: {
      auto ptr = reinterpret_cast<const KeyValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KeyValueValue_KeyValueString: {
      auto ptr = reinterpret_cast<const KeyValueString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KeyValueValue_KeyValueVector: {
      auto ptr = reinterpret_cast<const KeyValueVector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyKeyValueValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyKeyValueValue(
        verifier,  values->Get(i), types->GetEnum<KeyValueValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const Schemas::Map::Header *GetHeader(const void *buf) {
  return flatbuffers::GetRoot<Schemas::Map::Header>(buf);
}

inline const Schemas::Map::Header *GetSizePrefixedHeader(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Schemas::Map::Header>(buf);
}

inline bool VerifyHeaderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Schemas::Map::Header>(nullptr);
}

inline bool VerifySizePrefixedHeaderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Schemas::Map::Header>(nullptr);
}

inline void FinishHeaderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Schemas::Map::Header> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedHeaderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Schemas::Map::Header> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Map
}  // namespace Schemas

#endif  // FLATBUFFERS_GENERATED_EMF_SCHEMAS_MAP_H_
